// SPDX-License-Identifier: GPL-2.0
/*
 * Copyright (c) 2021 Telegram FZ-LLC
 * Copyright (c) 2022 Meta Platforms, Inc. and affiliates.
 */

#define _GNU_SOURCE

#include "filter-table.h"

#include <linux/kernel.h>
#include <linux/err.h>

#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

#include <bpf/bpf.h>

#include "bpfilter.h"
#include "codegen.h"
#include "context.h"
#include "logger.h"
#include "msgfmt.h"
#include "rule.h"
#include "sockopt.h"

struct filter_table_context {
	struct shared_codegen shared;
	struct codegen local_in;
	struct codegen forward;
	struct codegen local_out;
};

static struct table *filter_table_create(struct context *ctx,
					 const struct bpfilter_ipt_replace *ipt_replace)
{
	struct table *t = create_table(ctx, ipt_replace);

	if (!IS_ERR_OR_NULL(t))
		t->table_ops = &filter_table_ops;

	return t;
}

static int filter_table_codegen(struct context *ctx, struct table *table)
{
	struct filter_table_context *table_ctx;
	int r;

	BUG_ON(table->table_ops != &filter_table_ops);

	if (table->ctx) {
		BFLOG_ERR("filter table has no context");
		return -EINVAL;
	}

	table_ctx = calloc(1, sizeof(*table_ctx));
	if (!table_ctx) {
		BFLOG_ERR("out of memory");
		return -ENOMEM;
	}

	create_shared_codegen(&table_ctx->shared);

	// INPUT chain
	r = create_codegen(&table_ctx->local_in, BPF_PROG_TYPE_SCHED_CLS);
	if (r) {
		BFLOG_ERR("TC codegen for INPUT chain creation failed");
		goto err_free_table_ctx;
	}

	table_ctx->local_in.ctx = ctx;
	table_ctx->local_in.shared_codegen = &table_ctx->shared;
	table_ctx->local_in.iptables_hook = BPFILTER_INET_HOOK_LOCAL_IN;
	table_ctx->local_in.bpf_tc_hook = BPF_TC_INGRESS;

	r = try_codegen(&table_ctx->local_in, table);
	if (r) {
		BFLOG_ERR("failed to generate LOCAL_IN code");
		goto err_free_local_in;
	}

	// FORWARD chain
	r = create_codegen(&table_ctx->forward, BPF_PROG_TYPE_SCHED_CLS);
	if (r) {
		BFLOG_ERR("TC codegen for FORWARD chain create failed");
		goto err_free_local_in;
	}

	table_ctx->forward.ctx = ctx;
	table_ctx->forward.shared_codegen = &table_ctx->shared;
	table_ctx->forward.iptables_hook = BPFILTER_INET_HOOK_FORWARD;
	table_ctx->forward.bpf_tc_hook = BPF_TC_INGRESS;

	r = try_codegen(&table_ctx->forward, table);
	if (r) {
		BFLOG_ERR("failed to generate LOCAL_FORWARD code");
		goto err_free_local_fwd;
	}

	// OUTPUT chain
	r = create_codegen(&table_ctx->local_out, BPF_PROG_TYPE_SCHED_CLS);
	if (r) {
		BFLOG_ERR("TC codegen for OUTPUT chain creation failed");
		goto err_free_local_fwd;
	}

	table_ctx->local_out.ctx = ctx;
	table_ctx->local_out.shared_codegen = &table_ctx->shared;
	table_ctx->local_out.iptables_hook = BPFILTER_INET_HOOK_LOCAL_OUT;
	table_ctx->local_out.bpf_tc_hook = BPF_TC_EGRESS;

	r = try_codegen(&table_ctx->local_out, table);
	if (r) {
		BFLOG_ERR("failed to generate LOCAL_OUT code");
		goto err_free_local_out;
	}

	table->ctx = table_ctx;

	return 0;

err_free_local_out:
	free_codegen(&table_ctx->local_out);
err_free_local_fwd:
	free_codegen(&table_ctx->forward);
err_free_local_in:
	free_codegen(&table_ctx->local_in);
err_free_table_ctx:
	free(table_ctx);

	return r;
}

static int filter_table_install(struct context *ctx, struct table *table)
{
	struct filter_table_context *table_ctx;
	int r;

	if (!table->ctx)
		return -EINVAL;

	table_ctx = (struct filter_table_context *)table->ctx;

	r = table_ctx->local_in.codegen_ops->load_img(&table_ctx->local_in);
	if (r < 0) {
		BFLOG_ERR("failed to load chain INPUT in table filter: %s",
			  table_ctx->local_in.log_buf);
		return r;
	}

	r = table_ctx->forward.codegen_ops->load_img(&table_ctx->forward);
	if (r < 0) {
		BFLOG_ERR("failed to load chain FORWARD in table filter: %s",
			  table_ctx->forward.log_buf);
		goto err_unload_local_in;
	}

	r = table_ctx->local_out.codegen_ops->load_img(&table_ctx->local_out);
	if (r < 0) {
		BFLOG_ERR("failed to load chain OUTPUT in table filter: %s",
			  table_ctx->local_out.log_buf);
		goto err_unload_forward;
	}

	BFLOG_DBG("installed filter table");

	return 0;

err_unload_forward:
	table_ctx->forward.codegen_ops->unload_img(&table_ctx->forward);
err_unload_local_in:
	table_ctx->local_in.codegen_ops->unload_img(&table_ctx->local_in);

	return r;
}

static void filter_table_uninstall(struct context *ctx, struct table *table)
{
	struct filter_table_context *table_ctx;

	BUG_ON(!table->ctx);

	table_ctx = (struct filter_table_context *)table->ctx;

	table_ctx->local_in.codegen_ops->unload_img(&table_ctx->local_in);
	table_ctx->forward.codegen_ops->unload_img(&table_ctx->forward);
	table_ctx->local_out.codegen_ops->unload_img(&table_ctx->local_out);
}

static void filter_table_free(struct table *table)
{
	if (table->ctx) {
		struct filter_table_context *table_ctx;

		table_ctx = (struct filter_table_context *)table->ctx;

		free_codegen(&table_ctx->local_in);
		free_codegen(&table_ctx->forward);
		free_codegen(&table_ctx->local_out);
		free(table_ctx);
	}

	free_table(table);
}

static void filter_table_update_counters(struct table *table)
{
	int r;
	struct rule *rule;
	struct filter_table_context *ctx = table->ctx;
	struct shared_codegen *shared = &ctx->shared;
	int map_fd = shared->maps_fd[CODEGEN_MAP_COUNTERS];

	for (uint32_t i = 0; i < table->num_rules; ++i) {
		rule = &table->rules[i];

		r = bpf_map_lookup_elem(map_fd, &rule->index,
					(void *)&rule->ipt_entry->counters);
		if (r < 0) {
			BFLOG_DBG("couldn't fetch counter for rule at %p",
				  rule);
		}
	}
}

const struct table_ops filter_table_ops = {
	.name = "filter",
	.create = filter_table_create,
	.codegen = filter_table_codegen,
	.install = filter_table_install,
	.uninstall = filter_table_uninstall,
	.free = filter_table_free,
	.update_counters = filter_table_update_counters
};

static uint8_t filter_table_replace_blob[] = {
	0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0e, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
	0x78, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00,
	0x30, 0x01, 0x00, 0x00,	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x98, 0x00, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
	0x10, 0x32, 0x40, 0x36, 0x43, 0x56, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xfe, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xfe, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xfe, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x45, 0x52, 0x52, 0x4f, 0x52, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

int create_filter_table(struct context *ctx)
{
	struct mbox_request req;

	req.addr = (__u64)filter_table_replace_blob;
	req.len = ARRAY_SIZE(filter_table_replace_blob);
	req.is_set = 1;
	req.cmd = BPFILTER_IPT_SO_SET_REPLACE;
	req.pid = getpid();

	return handle_sockopt_request(ctx, &req);
}
